#include "imports/stdlib.fc";

const op::admin_withdraw = "op::admin_withdraw"c;
const op::payment = "op::payment"c;

global slice admin_addr;
global int percent;

int are_slices_equal?(slice a, slice b) asm "SDEQ";

() save_data() impure {
    set_data(
        begin_cell()
            .store_slice(admin_addr)
            .store_uint(percent, 9)
            .end_cell()
    );
}

() load_data() impure {
    var ds = get_data().begin_parse();

    admin_addr = ds~load_msg_addr();
    percent = ds~load_uint(9);

    ds.end_parse();
}

(slice) get_admin_address() method_id {
    slice ds = get_data().begin_parse();
    if (ds.slice_empty?()) {
        return null();
    }
    slice admin_addr = ds~load_msg_addr();
    return admin_addr;
}

(int) get_commission_percent() method_id {
    slice ds = get_data().begin_parse();
    if (ds.slice_empty?()) {
        return 0;
    }
    ds~load_msg_addr();
    int commission = ds~load_uint(9);
    return commission;
}

(int) get_current_commission_pool_balance() method_id {
    [int balance_nano, cell extra_currencies_dict] = get_balance();
    return balance_nano;
}

(int) commission_deduction(int amount) inline {
    int fee = amount * percent / 100;
    return amount - fee;
}

() withdraw(slice msg_sender, int amount) impure inline {
    throw_unless(are_slices_equal?(admin_addr, msg_sender), 101);

    [int balance_nano, cell extra_currencies_dict] = get_balance();
    int reserve = 10000000;
    throw_unless(amount + reserve <= balance_nano, 102);

    int stored_commission = get_current_commission_pool_balance();
    throw_unless(amount <= stored_commission, 103);

    save_data();

    var msg_body = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(admin_addr)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .end_cell();

    send_raw_message(msg_body, 64);
}

() send_payment(slice destination_address, int amount) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(destination_address)
        .store_coins(amount)
        .end_cell();
    send_raw_message(msg, 64);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) {
    if (in_msg.slice_empty?()) {
        return ();
    }

    load_data();

    int op = in_msg~load_uint(32);

    if (op == op::admin_withdraw) {
        slice msg_sender = in_msg~load_msg_addr();
        int amount = in_msg~load_coins();

        withdraw(msg_sender, amount);
    }

    if (op == op::payment) {
        slice seller = in_msg~load_msg_addr();
        int payout = commission_deduction(msg_value);

        send_payment(seller, payout);
    }
}
